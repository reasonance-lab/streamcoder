import streamlit as st
import streamlit.components.v1 as components

def main():
    st.set_page_config(page_title="Tetris Game", layout="wide")
    st.title("Tetris Game")

    # HTML content with React and Tetris game implementation
    html_content = """
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Tetris Game</title>
        <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
        <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
        <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
        <style>
            body {
                font-family: Arial, sans-serif;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                margin: 0;
                background-color: #f0f0f0;
            }
            #game-container {
                text-align: center;
            }
            canvas {
                border: 2px solid #333;
            }
            @media (max-width: 600px) {
                canvas {
                    width: 90vw;
                    height: 180vw;
                }
            }
        </style>
    </head>
    <body>
        <div id="root"></div>
        <script type="text/babel">
            const COLS = 10;
            const ROWS = 20;
            const BLOCK_SIZE = 30;
            const COLORS = [
                'cyan', 'blue', 'orange', 'yellow', 'green', 'purple', 'red'
            ];

            const SHAPES = [
                [[1, 1, 1, 1]],
                [[1, 1, 1], [1]],
                [[1, 1, 1], [0, 0, 1]],
                [[1, 1], [1, 1]],
                [[1, 1, 0], [0, 1, 1]],
                [[0, 1, 1], [1, 1]],
                [[0, 1, 0], [1, 1, 1]]
            ];

            function createMatrix(w, h) {
                return Array.from({ length: h }, () => new Array(w).fill(0));
            }

            function collide(arena, player) {
                const [m, o] = [player.matrix, player.pos];
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < m[y].length; ++x) {
                        if (m[y][x] !== 0 &&
                            (arena[y + o.y] &&
                            arena[y + o.y][x + o.x]) !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function merge(arena, player) {
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            arena[y + player.pos.y][x + player.pos.x] = value;
                        }
                    });
                });
            }

            function rotate(matrix, dir) {
                for (let y = 0; y < matrix.length; ++y) {
                    for (let x = 0; x < y; ++x) {
                        [
                            matrix[x][y],
                            matrix[y][x],
                        ] = [
                            matrix[y][x],
                            matrix[x][y],
                        ];
                    }
                }
                if (dir > 0) {
                    matrix.forEach(row => row.reverse());
                } else {
                    matrix.reverse();
                }
            }

            function playerDrop(arena, player, setArena, setPlayer, resetPlayer) {
                player.pos.y++;
                if (collide(arena, player)) {
                    player.pos.y--;
                    merge(arena, player);
                    resetPlayer();
                    setArena([...arena]);
                    return true;
                }
                setPlayer({...player});
                return false;
            }

            function playerMove(arena, player, dir) {
                player.pos.x += dir;
                if (collide(arena, player)) {
                    player.pos.x -= dir;
                    return false;
                }
                return true;
            }

            function playerRotate(arena, player, dir) {
                const pos = player.pos.x;
                let offset = 1;
                rotate(player.matrix, dir);
                while (collide(arena, player)) {
                    player.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > player.matrix[0].length) {
                        rotate(player.matrix, -dir);
                        player.pos.x = pos;
                        return;
                    }
                }
            }

            function Tetris() {
                const [arena, setArena] = React.useState(createMatrix(COLS, ROWS));
                const [player, setPlayer] = React.useState({
                    pos: {x: 0, y: 0},
                    matrix: null,
                    score: 0,
                });
                const [gameOver, setGameOver] = React.useState(false);
                const canvasRef = React.useRef(null);

                React.useEffect(() => {
                    const canvas = canvasRef.current;
                    const context = canvas.getContext('2d');
                    context.scale(BLOCK_SIZE, BLOCK_SIZE);

                    function resetPlayer() {
                        const pieces = 'ILJOTSZ';
                        const tetromino = pieces[Math.floor(Math.random() * pieces.length)];
                        player.matrix = SHAPES[pieces.indexOf(tetromino)];
                        player.pos.y = 0;
                        player.pos.x = Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);

                        if (collide(arena, player)) {
                            setGameOver(true);
                        }

                        setPlayer({...player});
                    }

                    function gameLoop() {
                        if (!gameOver) {
                            playerDrop(arena, player, setArena, setPlayer, resetPlayer);
                            draw();
                            requestAnimationFrame(gameLoop);
                        }
                    }

                    function draw() {
                        context.fillStyle = '#000';
                        context.fillRect(0, 0, canvas.width, canvas.height);

                        drawMatrix(arena, {x: 0, y: 0});
                        drawMatrix(player.matrix, player.pos);
                    }

                    function drawMatrix(matrix, offset) {
                        matrix.forEach((row, y) => {
                            row.forEach((value, x) => {
                                if (value !== 0) {
                                    context.fillStyle = COLORS[value - 1];
                                    context.fillRect(x + offset.x, y + offset.y, 1, 1);
                                }
                            });
                        });
                    }

                    resetPlayer();
                    gameLoop();

                    const handleKeyDown = (e) => {
                        if (gameOver) return;

                        if (e.keyCode === 37) {
                            playerMove(arena, player, -1);
                        } else if (e.keyCode === 39) {
                            playerMove(arena, player, 1);
                        } else if (e.keyCode === 40) {
                            playerDrop(arena, player, setArena, setPlayer, resetPlayer);
                        } else if (e.keyCode === 38) {
                            playerRotate(arena, player, 1);
                        }
                        setPlayer({...player});
                    };

                    document.addEventListener('keydown', handleKeyDown);

                    return () => {
                        document.removeEventListener('keydown', handleKeyDown);
                    };
                }, []);

                return (
                    <div id="game-container">
                        <canvas ref={canvasRef} width={COLS * BLOCK_SIZE} height={ROWS * BLOCK_SIZE}></canvas>
                        {gameOver && <div>Game Over</div>}
                    </div>
                );
            }

            ReactDOM.render(<Tetris />, document.getElementById('root'));
        </script>
    </body>
    </html>
    """

    # Render the HTML content
    components.html(html_content, height=600)

if __name__ == "__main__":
    main()